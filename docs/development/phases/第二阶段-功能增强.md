# 第二阶段：功能增强（2-4个月）

## 阶段目标

### 总体目标
在第一阶段基础上，增加流量分析和高级检测能力，提升系统的检测覆盖面和准确性，构建更完善的内容合规检测体系。

### 详细目标

#### 1. 技术架构升级目标
- **流量分析架构**：集成Suricata IDS引擎，构建实时流量分析能力
- **分布式处理**：支持多节点流量分析，提升处理能力
- **数据流优化**：建立高效的日志处理和存储机制
- **监控体系**：完善系统监控和告警机制
- **内存安全增强**：建立分布式内存监控，防止多节点OOM
- **资源管理优化**：实现跨节点的资源调度和清理机制

#### 2. 功能扩展目标
- **流量分析能力**：
  - 实时网络流量镜像接收和分析
  - 支持10+种威胁检测规则（DDoS、VPN、端口扫描、SQL注入等）
  - 流量特征提取和异常行为识别
  - 与网站检测结果关联分析
- **网站检测增强**：
  - 子域名递归扫描（支持3级深度）
  - 深度页面爬取（每个域名最多50个页面）
  - 多线程并发检测（支持50个并发任务）
  - 检测结果缓存优化（减少重复检测）
- **告警处置升级**：
  - 智能告警聚合和去重
  - 自动化处置流程（IP封禁、域名暂停、带宽限制）
  - 工单系统集成
  - 处置效果跟踪和反馈
- **Web管理后台增强**：
  - 流量监控实时仪表盘
  - 威胁情报展示
  - 自动处置配置界面
  - 高级报表和统计分析

#### 3. 性能提升目标
- **流量处理能力**：支持1Gbps流量实时分析
- **检测规模**：支持1000+域名的子域名扫描
- **并发处理**：支持50个网站并发检测
- **响应时间**：流量告警延迟≤30秒
- **存储优化**：支持100万条检测记录的高效查询
- **内存安全**：多节点内存使用率≤75%，自动负载均衡
- **资源管理**：跨节点资源调度，防止单点OOM

#### 4. 检测能力目标
- **覆盖面扩展**：
  - 网站检测覆盖率提升至95%（包含子域名）
  - 流量威胁检测类型≥10种
  - 支持多种协议识别（HTTP/HTTPS/DNS/SMTP等）
- **准确性提升**：
  - 流量威胁检测准确率≥85%
  - 子域名发现准确率≥90%
  - 告警误报率降低至≤5%
- **智能化水平**：
  - 告警关联分析准确率≥80%
  - 自动处置成功率≥90%
  - 威胁等级判定准确率≥85%

#### 5. 运维效率目标
- **自动化程度**：
  - 80%的常见威胁支持自动处置
  - 告警处理时间缩短50%
  - 系统部署时间≤30分钟
- **可观测性**：
  - 实时监控指标≥20个
  - 日志检索响应时间≤5秒
  - 系统健康度可视化展示
- **扩展性**：
  - 支持水平扩展至5个检测节点
  - 新增检测规则部署时间≤10分钟
  - 模块独立升级不影响其他功能

#### 6. 业务价值目标
- **威胁发现能力**：
  - 新增流量威胁发现能力，覆盖网络层攻击
  - 子域名扫描发现隐藏的违规内容
  - 深度检测提升内容合规覆盖率
- **处置效率**：
  - 自动处置响应时间≤5分钟
  - 减少人工干预80%
  - 威胁处置成功率≥95%
- **合规保障**：
  - 全面覆盖网站和网络两个维度
  - 建立完整的证据链和审计日志
  - 支持合规报告自动生成

## 开发顺序

1. **流量分析模块**（新增功能）
2. **网站检测模块增强**（子域名扫描、深度爬取）
3. **告警处置模块增强**（自动处置、工单集成）
4. **Web管理后台增强**（流量监控界面）

## 详细模块设计

### 1. 流量分析模块 (traffic-analyzer) - 新增

**功能职责：**
- 网络流量镜像接收
- 流量特征分析
- 异常行为检测
- 实时告警触发

**技术栈：**
- Suricata (IDS引擎)
- Python (规则管理)
- nDPI (协议识别)
- FastAPI (管理接口)

**目录结构：**
```
traffic-analyzer/
├── suricata/
│   ├── suricata.yaml           # Suricata配置
│   ├── rules/
│   │   ├── compliance.rules    # 合规检测规则
│   │   ├── ddos.rules          # DDoS检测规则
│   │   └── vpn.rules           # VPN检测规则
│   └── logs/
├── app/
│   ├── __init__.py
│   ├── main.py                 # 管理API入口
│   ├── services/
│   │   ├── __init__.py
│   │   ├── rule_manager.py     # 规则管理
│   │   ├── log_parser.py       # 日志解析
│   │   └── alert_processor.py  # 告警处理
│   └── models/
│       ├── __init__.py
│       └── traffic_event.py    # 流量事件模型
├── scripts/
│   ├── install_suricata.sh     # 安装脚本
│   └── update_rules.py         # 规则更新脚本
├── tests/
├── requirements.txt
└── docker-compose.yml
```

**开发优先级：** 高（新增核心功能）
**预估工期：** 4-5周

**核心功能实现：**

**Suricata规则配置示例：**
```yaml
# suricata.yaml 核心配置
default-log-dir: /var/log/suricata/

outputs:
  - fast:
      enabled: yes
      filename: fast.log
  - eve-log:
      enabled: yes
      filetype: regular
      filename: eve.json
      types:
        - alert
        - http
        - dns
        - tls
        - files
        - smtp

rule-files:
  - compliance.rules
  - ddos.rules
  - vpn.rules
  - emerging-threats.rules

default-rule-path: /etc/suricata/rules

af-packet:
  - interface: eth0
    cluster-id: 99
    cluster-type: cluster_flow
    defrag: yes

detect:
  profile: medium
  custom-values:
    toclient-groups: 3
    toserver-groups: 25

threading:
  set-cpu-affinity: no
  cpu-affinity:
    - management-cpu-set:
        cpu: [ 0 ]
    - receive-cpu-set:
        cpu: [ 0 ]
    - worker-cpu-set:
        cpu: [ "1-3" ]
```

**检测规则示例：**
```bash
# compliance.rules - 合规检测规则

# 1. 检测疑似DDoS攻击流量
alert tcp any any -> any 80 (msg:"疑似HTTP洪水攻击"; flow:stateless; threshold: type limit, track by_src, count 500, seconds 1; sid:100001; rev:1;)

# 2. 检测未授权VPN流量（OpenVPN特征）
alert tcp any any -> any 1194 (msg:"疑似未授权OpenVPN流量"; content:"|38 81 00 00 00 00 00 00|"; depth:8; sid:100002; rev:1;)

# 3. 检测端口扫描行为
alert tcp any any -> any any (msg:"疑似端口扫描"; flow:stateless; threshold: type limit, track by_src, count 100, seconds 10; sid:100003; rev:1;)

# 4. 检测SQL注入攻击
alert http any any -> any any (msg:"疑似SQL注入攻击"; content:"union"; nocase; content:"select"; nocase; distance:0; within:100; sid:100004; rev:1;)

# 5. 检测XSS攻击
alert http any any -> any any (msg:"疑似XSS攻击"; content:"<script"; nocase; sid:100005; rev:1;)

# 6. 检测文件上传攻击
alert http any any -> any any (msg:"疑似恶意文件上传"; content:"Content-Type: multipart/form-data"; content:".php"; distance:0; within:1000; sid:100006; rev:1;)

# 7. 检测暗网访问（Tor流量特征）
alert tcp any any -> any any (msg:"疑似Tor暗网访问"; content:"|16 03|"; depth:2; content:"|01|"; distance:3; within:1; sid:100007; rev:1;)

# 8. 检测加密货币挖矿流量
alert tcp any any -> any [8333,18333,8332,18332] (msg:"疑似比特币挖矿流量"; sid:100008; rev:1;)

# 9. 检测P2P文件共享
alert tcp any any -> any [6881:6889,6969] (msg:"疑似BitTorrent流量"; sid:100009; rev:1;)

# 10. 检测异常DNS查询
alert dns any any -> any any (msg:"疑似DNS隧道"; dns_query; content:".onion"; nocase; sid:100010; rev:1;)
```

**日志解析服务：**
```python
# log_parser.py
import json
import re
from datetime import datetime
from typing import Dict, List, Optional
from pathlib import Path

class SuricataLogParser:
    def __init__(self, log_path: str = "/var/log/suricata/eve.json"):
        self.log_path = Path(log_path)
        self.alert_patterns = {
            'ddos': re.compile(r'HTTP洪水攻击|DDoS'),
            'vpn': re.compile(r'VPN|OpenVPN'),
            'scan': re.compile(r'端口扫描|Port Scan'),
            'injection': re.compile(r'SQL注入|XSS'),
            'malware': re.compile(r'恶意软件|Malware'),
            'tor': re.compile(r'Tor|暗网'),
            'mining': re.compile(r'挖矿|Mining'),
            'p2p': re.compile(r'BitTorrent|P2P')
        }
    
    def parse_alerts(self, limit: int = 100) -> List[Dict]:
        """解析告警日志"""
        alerts = []
        try:
            with open(self.log_path, 'r', encoding='utf-8') as f:
                for line in f:
                    try:
                        log_entry = json.loads(line.strip())
                        if log_entry.get('event_type') == 'alert':
                            alert = self._parse_alert(log_entry)
                            if alert:
                                alerts.append(alert)
                                if len(alerts) >= limit:
                                    break
                    except json.JSONDecodeError:
                        continue
        except FileNotFoundError:
            print(f"日志文件不存在: {self.log_path}")
        
        return alerts
    
    def _parse_alert(self, log_entry: Dict) -> Optional[Dict]:
        """解析单个告警事件"""
        alert = log_entry.get('alert', {})
        if not alert:
            return None
        
        # 提取基础信息
        parsed_alert = {
            'timestamp': log_entry.get('timestamp'),
            'src_ip': log_entry.get('src_ip'),
            'src_port': log_entry.get('src_port'),
            'dest_ip': log_entry.get('dest_ip'),
            'dest_port': log_entry.get('dest_port'),
            'protocol': log_entry.get('proto'),
            'signature': alert.get('signature'),
            'signature_id': alert.get('signature_id'),
            'category': alert.get('category'),
            'severity': alert.get('severity')
        }
        
        # 分类告警类型
        signature = alert.get('signature', '')
        for alert_type, pattern in self.alert_patterns.items():
            if pattern.search(signature):
                parsed_alert['alert_type'] = alert_type
                break
        else:
            parsed_alert['alert_type'] = 'unknown'
        
        # 计算风险等级
        parsed_alert['risk_level'] = self._calculate_risk_level(parsed_alert)
        
        return parsed_alert
    
    def _calculate_risk_level(self, alert: Dict) -> str:
        """计算风险等级"""
        severity = alert.get('severity', 3)
        alert_type = alert.get('alert_type', 'unknown')
        
        # 高风险类型
        high_risk_types = ['ddos', 'injection', 'malware']
        # 中风险类型
        medium_risk_types = ['vpn', 'scan', 'tor']
        
        if alert_type in high_risk_types or severity <= 1:
            return 'high'
        elif alert_type in medium_risk_types or severity <= 2:
            return 'medium'
        else:
            return 'low'
    
    def get_statistics(self, hours: int = 24) -> Dict:
        """获取统计信息"""
        alerts = self.parse_alerts(limit=10000)
        
        # 按类型统计
        type_stats = {}
        risk_stats = {'high': 0, 'medium': 0, 'low': 0}
        
        for alert in alerts:
            alert_type = alert.get('alert_type', 'unknown')
            risk_level = alert.get('risk_level', 'low')
            
            type_stats[alert_type] = type_stats.get(alert_type, 0) + 1
            risk_stats[risk_level] += 1
        
        return {
            'total_alerts': len(alerts),
            'type_distribution': type_stats,
            'risk_distribution': risk_stats,
            'top_sources': self._get_top_sources(alerts),
            'top_targets': self._get_top_targets(alerts)
        }
    
    def _get_top_sources(self, alerts: List[Dict], limit: int = 10) -> List[Dict]:
        """获取TOP攻击源IP"""
        source_count = {}
        for alert in alerts:
            src_ip = alert.get('src_ip')
            if src_ip:
                source_count[src_ip] = source_count.get(src_ip, 0) + 1
        
        return sorted(
            [{'ip': ip, 'count': count} for ip, count in source_count.items()],
            key=lambda x: x['count'],
            reverse=True
        )[:limit]
    
    def _get_top_targets(self, alerts: List[Dict], limit: int = 10) -> List[Dict]:
        """获取TOP攻击目标IP"""
        target_count = {}
        for alert in alerts:
            dest_ip = alert.get('dest_ip')
            if dest_ip:
                target_count[dest_ip] = target_count.get(dest_ip, 0) + 1
        
        return sorted(
            [{'ip': ip, 'count': count} for ip, count in target_count.items()],
            key=lambda x: x['count'],
            reverse=True
        )[:limit]
```

### 2. 网站检测模块增强

**新增功能：**
- 子域名递归扫描
- 深度页面爬取
- 多线程并发检测
- 检测结果缓存优化

**子域名扫描实现：**
```python
# subdomain_scanner.py
import dns.resolver
import requests
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Set

class SubdomainScanner:
    def __init__(self, max_workers: int = 10):
        self.max_workers = max_workers
        self.common_subdomains = [
            'www', 'mail', 'ftp', 'admin', 'api', 'blog', 'shop', 'forum',
            'test', 'dev', 'staging', 'cdn', 'img', 'static', 'assets',
            'app', 'mobile', 'm', 'wap', 'secure', 'vpn', 'remote'
        ]
    
    def scan_subdomains(self, domain: str, use_bruteforce: bool = True) -> Set[str]:
        """扫描子域名"""
        subdomains = set()
        
        # 1. 暴力破解常见子域名
        if use_bruteforce:
            subdomains.update(self._bruteforce_subdomains(domain))
        
        # 2. 通过证书透明度日志查找
        subdomains.update(self._search_certificate_logs(domain))
        
        # 3. 通过搜索引擎查找
        subdomains.update(self._search_engines(domain))
        
        return subdomains
    
    def _bruteforce_subdomains(self, domain: str) -> Set[str]:
        """暴力破解子域名"""
        found_subdomains = set()
        
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            futures = {
                executor.submit(self._check_subdomain, f"{sub}.{domain}"): sub
                for sub in self.common_subdomains
            }
            
            for future in as_completed(futures):
                subdomain = future.result()
                if subdomain:
                    found_subdomains.add(subdomain)
        
        return found_subdomains
    
    def _check_subdomain(self, subdomain: str) -> str:
        """检查子域名是否存在"""
        try:
            # DNS解析检查
            dns.resolver.resolve(subdomain, 'A')
            
            # HTTP访问检查
            response = requests.get(f"http://{subdomain}", timeout=5)
            if response.status_code < 400:
                return subdomain
        except:
            pass
        
        return None
    
    def _search_certificate_logs(self, domain: str) -> Set[str]:
        """通过证书透明度日志查找子域名"""
        subdomains = set()
        try:
            # 使用crt.sh API
            url = f"https://crt.sh/?q=%.{domain}&output=json"
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                certificates = response.json()
                for cert in certificates:
                    name_value = cert.get('name_value', '')
                    for line in name_value.split('\n'):
                        if line.endswith(f'.{domain}'):
                            subdomains.add(line.strip())
        except:
            pass
        
        return subdomains
    
    def _search_engines(self, domain: str) -> Set[str]:
        """通过搜索引擎查找子域名"""
        # 这里可以集成Google、Bing等搜索引擎API
        # 由于API限制，这里只是示例框架
        return set()
```

**深度爬取实现：**
```python
# deep_crawler.py
import asyncio
import aiohttp
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
from typing import Set, List, Dict

class DeepCrawler:
    def __init__(self, max_depth: int = 3, max_pages: int = 50):
        self.max_depth = max_depth
        self.max_pages = max_pages
        self.visited_urls = set()
        self.crawled_content = []
    
    async def crawl_website(self, start_url: str) -> List[Dict]:
        """深度爬取网站"""
        async with aiohttp.ClientSession() as session:
            await self._crawl_recursive(session, start_url, 0)
        
        return self.crawled_content
    
    async def _crawl_recursive(self, session: aiohttp.ClientSession, url: str, depth: int):
        """递归爬取页面"""
        if depth > self.max_depth or len(self.crawled_content) >= self.max_pages:
            return
        
        if url in self.visited_urls:
            return
        
        self.visited_urls.add(url)
        
        try:
            async with session.get(url, timeout=10) as response:
                if response.status == 200:
                    html = await response.text()
                    soup = BeautifulSoup(html, 'html.parser')
                    
                    # 提取页面内容
                    content = {
                        'url': url,
                        'title': soup.title.string if soup.title else '',
                        'text': soup.get_text(),
                        'images': [img.get('src') for img in soup.find_all('img') if img.get('src')],
                        'links': [a.get('href') for a in soup.find_all('a') if a.get('href')],
                        'depth': depth
                    }
                    
                    self.crawled_content.append(content)
                    
                    # 获取同域名下的链接继续爬取
                    base_domain = urlparse(url).netloc
                    for link in content['links']:
                        full_url = urljoin(url, link)
                        if urlparse(full_url).netloc == base_domain:
                            await self._crawl_recursive(session, full_url, depth + 1)
        
        except Exception as e:
            print(f"爬取失败: {url}, 错误: {e}")
```

### 3. 告警处置模块增强

**新增功能：**
- 自动化处置流程
- 工单系统集成
- 告警聚合和去重
- 处置效果跟踪

**自动处置服务：**
```python
# auto_action.py
import requests
import time
from typing import Dict, List
from enum import Enum

class ActionType(Enum):
    BLOCK_IP = "block_ip"
    SUSPEND_DOMAIN = "suspend_domain"
    LIMIT_BANDWIDTH = "limit_bandwidth"
    SEND_WARNING = "send_warning"
    CREATE_TICKET = "create_ticket"

class AutoActionService:
    def __init__(self, config: Dict):
        self.config = config
        self.firewall_api = config.get('firewall_api')
        self.idc_api = config.get('idc_api')
        self.ticket_api = config.get('ticket_api')
    
    def execute_action(self, alert: Dict, action_type: ActionType) -> Dict:
        """执行自动处置动作"""
        try:
            if action_type == ActionType.BLOCK_IP:
                return self._block_ip(alert)
            elif action_type == ActionType.SUSPEND_DOMAIN:
                return self._suspend_domain(alert)
            elif action_type == ActionType.LIMIT_BANDWIDTH:
                return self._limit_bandwidth(alert)
            elif action_type == ActionType.SEND_WARNING:
                return self._send_warning(alert)
            elif action_type == ActionType.CREATE_TICKET:
                return self._create_ticket(alert)
            else:
                return {'success': False, 'message': '未知的处置类型'}
        except Exception as e:
            return {'success': False, 'message': f'处置执行失败: {str(e)}'}
    
    def _block_ip(self, alert: Dict) -> Dict:
        """封禁IP地址"""
        src_ip = alert.get('src_ip')
        if not src_ip:
            return {'success': False, 'message': '缺少源IP地址'}
        
        # 调用防火墙API封禁IP
        response = requests.post(
            f"{self.firewall_api}/block",
            json={'ip': src_ip, 'duration': 3600},  # 封禁1小时
            headers={'Authorization': f"Bearer {self.config['firewall_token']}"}
        )
        
        if response.status_code == 200:
            return {
                'success': True,
                'message': f'IP {src_ip} 已被封禁',
                'action_id': response.json().get('action_id')
            }
        else:
            return {'success': False, 'message': f'封禁失败: {response.text}'}
    
    def _suspend_domain(self, alert: Dict) -> Dict:
        """暂停域名服务"""
        domain = alert.get('domain')
        if not domain:
            return {'success': False, 'message': '缺少域名信息'}
        
        # 调用IDC API暂停域名
        response = requests.post(
            f"{self.idc_api}/domains/{domain}/suspend",
            json={'reason': '内容合规违规'},
            headers={'Authorization': f"Bearer {self.config['idc_token']}"}
        )
        
        if response.status_code == 200:
            return {
                'success': True,
                'message': f'域名 {domain} 已被暂停',
                'action_id': response.json().get('action_id')
            }
        else:
            return {'success': False, 'message': f'暂停失败: {response.text}'}
    
    def _limit_bandwidth(self, alert: Dict) -> Dict:
        """限制带宽"""
        src_ip = alert.get('src_ip')
        if not src_ip:
            return {'success': False, 'message': '缺少源IP地址'}
        
        # 调用网络设备API限制带宽
        response = requests.post(
            f"{self.firewall_api}/limit",
            json={'ip': src_ip, 'bandwidth': '1Mbps'},
            headers={'Authorization': f"Bearer {self.config['firewall_token']}"}
        )
        
        if response.status_code == 200:
            return {
                'success': True,
                'message': f'IP {src_ip} 带宽已被限制',
                'action_id': response.json().get('action_id')
            }
        else:
            return {'success': False, 'message': f'限制失败: {response.text}'}
    
    def _send_warning(self, alert: Dict) -> Dict:
        """发送警告通知"""
        # 这里可以发送邮件、短信或其他形式的警告
        return {
            'success': True,
            'message': '警告通知已发送',
            'action_id': f"warning_{int(time.time())}"
        }
    
    def _create_ticket(self, alert: Dict) -> Dict:
        """创建工单"""
        ticket_data = {
            'title': f"安全告警 - {alert.get('signature', '未知威胁')}",
            'description': f"""
            告警时间: {alert.get('timestamp')}
            源IP: {alert.get('src_ip')}
            目标IP: {alert.get('dest_ip')}
            告警类型: {alert.get('alert_type')}
            风险等级: {alert.get('risk_level')}
            详细信息: {alert.get('signature')}
            """,
            'priority': self._get_ticket_priority(alert.get('risk_level')),
            'category': 'security',
            'assignee': 'security-team'
        }
        
        response = requests.post(
            f"{self.ticket_api}/tickets",
            json=ticket_data,
            headers={'Authorization': f"Bearer {self.config['ticket_token']}"}
        )
        
        if response.status_code == 201:
            return {
                'success': True,
                'message': '安全工单已创建',
                'ticket_id': response.json().get('ticket_id')
            }
        else:
            return {'success': False, 'message': f'工单创建失败: {response.text}'}
    
    def _get_ticket_priority(self, risk_level: str) -> str:
        """根据风险等级确定工单优先级"""
        priority_map = {
            'high': 'urgent',
            'medium': 'high',
            'low': 'normal'
        }
        return priority_map.get(risk_level, 'normal')
```

### 4. Web管理后台增强

**新增功能：**
- 流量监控仪表盘
- 实时告警展示
- 子域名扫描管理
- 自动处置配置

**流量监控组件示例：**
```vue
<!-- TrafficMonitor.vue -->
<template>
  <div class="traffic-monitor">
    <el-row :gutter="20">
      <!-- 实时统计卡片 -->
      <el-col :span="6" v-for="stat in stats" :key="stat.key">
        <el-card class="stat-card">
          <div class="stat-content">
            <div class="stat-value">{{ stat.value }}</div>
            <div class="stat-label">{{ stat.label }}</div>
          </div>
          <div class="stat-icon">
            <i :class="stat.icon"></i>
          </div>
        </el-card>
      </el-col>
    </el-row>
    
    <!-- 告警趋势图表 -->
    <el-row :gutter="20" style="margin-top: 20px;">
      <el-col :span="12">
        <el-card title="告警趋势">
          <div ref="alertTrendChart" style="height: 300px;"></div>
        </el-card>
      </el-col>
      <el-col :span="12">
        <el-card title="攻击类型分布">
          <div ref="attackTypeChart" style="height: 300px;"></div>
        </el-card>
      </el-col>
    </el-row>
    
    <!-- 实时告警列表 -->
    <el-card title="实时告警" style="margin-top: 20px;">
      <el-table :data="realtimeAlerts" style="width: 100%">
        <el-table-column prop="timestamp" label="时间" width="180">
          <template #default="scope">
            {{ formatTime(scope.row.timestamp) }}
          </template>
        </el-table-column>
        <el-table-column prop="src_ip" label="源IP" width="120"></el-table-column>
        <el-table-column prop="dest_ip" label="目标IP" width="120"></el-table-column>
        <el-table-column prop="alert_type" label="类型" width="100">
          <template #default="scope">
            <el-tag :type="getAlertTypeColor(scope.row.alert_type)">
              {{ scope.row.alert_type }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="risk_level" label="风险等级" width="100">
          <template #default="scope">
            <el-tag :type="getRiskLevelColor(scope.row.risk_level)">
              {{ scope.row.risk_level }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="signature" label="描述" show-overflow-tooltip></el-table-column>
        <el-table-column label="操作" width="200">
          <template #default="scope">
            <el-button size="small" @click="handleAlert(scope.row)">处理</el-button>
            <el-button size="small" type="danger" @click="blockIP(scope.row)">封禁</el-button>
          </template>
        </el-table-column>
      </el-table>
    </el-card>
  </div>
</template>

<script>
import * as echarts from 'echarts'
import { ref, onMounted, onUnmounted } from 'vue'
import { getTrafficStats, getRealtimeAlerts } from '@/api/traffic'

export default {
  name: 'TrafficMonitor',
  setup() {
    const stats = ref([
      { key: 'total_alerts', label: '总告警数', value: 0, icon: 'el-icon-warning' },
      { key: 'high_risk', label: '高风险', value: 0, icon: 'el-icon-error' },
      { key: 'blocked_ips', label: '已封禁IP', value: 0, icon: 'el-icon-lock' },
      { key: 'active_threats', label: '活跃威胁', value: 0, icon: 'el-icon-lightning' }
    ])
    
    const realtimeAlerts = ref([])
    let alertTrendChart = null
    let attackTypeChart = null
    let refreshTimer = null
    
    const initCharts = () => {
      // 初始化告警趋势图表
      alertTrendChart = echarts.init(document.querySelector('.alert-trend-chart'))
      const alertTrendOption = {
        title: { text: '24小时告警趋势' },
        xAxis: { type: 'category', data: [] },
        yAxis: { type: 'value' },
        series: [{
          data: [],
          type: 'line',
          smooth: true
        }]
      }
      alertTrendChart.setOption(alertTrendOption)
      
      // 初始化攻击类型分布图表
      attackTypeChart = echarts.init(document.querySelector('.attack-type-chart'))
      const attackTypeOption = {
        title: { text: '攻击类型分布' },
        series: [{
          type: 'pie',
          data: []
        }]
      }
      attackTypeChart.setOption(attackTypeOption)
    }
    
    const loadData = async () => {
      try {
        // 加载统计数据
        const statsData = await getTrafficStats()
        stats.value.forEach(stat => {
          stat.value = statsData[stat.key] || 0
        })
        
        // 加载实时告警
        const alertsData = await getRealtimeAlerts()
        realtimeAlerts.value = alertsData.alerts || []
        
        // 更新图表数据
        if (alertTrendChart && statsData.trend_data) {
          alertTrendChart.setOption({
            xAxis: { data: statsData.trend_data.times },
            series: [{ data: statsData.trend_data.values }]
          })
        }
        
        if (attackTypeChart && statsData.type_distribution) {
          const pieData = Object.entries(statsData.type_distribution).map(([name, value]) => ({ name, value }))
          attackTypeChart.setOption({
            series: [{ data: pieData }]
          })
        }
      } catch (error) {
        console.error('加载数据失败:', error)
      }
    }
    
    const formatTime = (timestamp) => {
      return new Date(timestamp).toLocaleString()
    }
    
    const getAlertTypeColor = (type) => {
      const colorMap = {
        'ddos': 'danger',
        'injection': 'danger',
        'malware': 'danger',
        'vpn': 'warning',
        'scan': 'warning',
        'tor': 'warning'
      }
      return colorMap[type] || 'info'
    }
    
    const getRiskLevelColor = (level) => {
      const colorMap = {
        'high': 'danger',
        'medium': 'warning',
        'low': 'success'
      }
      return colorMap[level] || 'info'
    }
    
    const handleAlert = (alert) => {
      // 处理告警逻辑
      console.log('处理告警:', alert)
    }
    
    const blockIP = (alert) => {
      // 封禁IP逻辑
      console.log('封禁IP:', alert.src_ip)
    }
    
    onMounted(() => {
      initCharts()
      loadData()
      // 每30秒刷新一次数据
      refreshTimer = setInterval(loadData, 30000)
    })
    
    onUnmounted(() => {
      if (refreshTimer) {
        clearInterval(refreshTimer)
      }
      if (alertTrendChart) {
        alertTrendChart.dispose()
      }
      if (attackTypeChart) {
        attackTypeChart.dispose()
      }
    })
    
    return {
      stats,
      realtimeAlerts,
      formatTime,
      getAlertTypeColor,
      getRiskLevelColor,
      handleAlert,
      blockIP
    }
  }
}
</script>

<style scoped>
.traffic-monitor {
  padding: 20px;
}

.stat-card {
  position: relative;
  overflow: hidden;
}

.stat-content {
  padding: 20px;
}

.stat-value {
  font-size: 32px;
  font-weight: bold;
  color: #409EFF;
}

.stat-label {
  font-size: 14px;
  color: #666;
  margin-top: 8px;
}

.stat-icon {
  position: absolute;
  right: 20px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 48px;
  color: #E6F7FF;
}
</style>
```

## 阶段里程碑

### 里程碑检查点

- [ ] **流量分析模块完成**
  - Suricata部署和配置
  - 自定义检测规则库
  - 实时日志解析和告警
  - 流量统计和分析

- [ ] **网站检测模块增强完成**
  - 子域名递归扫描
  - 深度页面爬取（3层深度）
  - 多线程并发检测
  - 检测结果缓存优化

- [ ] **告警处置模块增强完成**
  - 自动化处置流程
  - 工单系统集成
  - 告警聚合和去重
  - 处置效果跟踪

- [ ] **Web管理后台增强完成**
  - 流量监控仪表盘
  - 实时告警展示
  - 子域名扫描管理
  - 自动处置配置界面

### 验收标准

1. **功能验收**
   - 能够实时检测和分析网络流量
   - 支持自动发现和扫描子域名
   - 检测到高风险事件时能自动执行处置动作
   - Web界面能实时展示流量监控数据

2. **性能验收**
   - 流量分析延迟不超过5秒
   - 子域名扫描速度不低于10个/分钟
   - 自动处置响应时间不超过30秒
   - 系统支持并发处理50个检测任务

3. **稳定性验收**
   - 流量分析模块连续运行7天无异常
   - 自动处置成功率不低于95%
   - 系统在高负载下能正常运行

## 技术难点与解决方案

### 1. 流量分析性能优化
**难点：** 大流量环境下Suricata性能瓶颈
**解决方案：**
- 采用流量采样（10%采样率）
- 多网卡负载均衡
- 规则优化和分级处理

### 2. 子域名扫描效率
**难点：** 大量子域名扫描耗时过长
**解决方案：**
- 多线程并发扫描
- DNS缓存优化
- 智能扫描策略（优先扫描常见子域名）

### 3. 误报率控制
**难点：** 自动处置可能产生误报
**解决方案：**
- 多维度告警确认机制
- 白名单和信任IP管理
- 人工审核流程

## 风险控制

### 技术风险
1. **流量分析准确性**
   - 风险：检测规则不够精确导致误报
   - 应对：建立规则测试环境，逐步优化规则库

2. **自动处置风险**
   - 风险：自动处置可能影响正常业务
   - 应对：设置处置白名单，重要IP需人工确认

### 业务风险
1. **系统性能影响**
   - 风险：流量分析消耗大量系统资源
   - 应对：独立部署流量分析节点，避免影响业务系统

2. **合规性风险**
   - 风险：流量监控可能涉及用户隐私
   - 应对：只分析流量特征，不存储具体内容

## 下一阶段准备

### 为第三阶段做准备
1. **性能优化准备**
   - 收集系统性能数据
   - 识别性能瓶颈点
   - 设计分布式架构方案

2. **用户体验优化**
   - 收集用户反馈
   - 分析界面使用习惯
   - 设计移动端方案

3. **数据分析准备**
   - 建立数据仓库
   - 设计报表需求
   - 准备机器学习算法

## 内存安全防护措施

### 1. 分布式内存监控
```python
# 分布式内存监控服务
class DistributedMemoryMonitor:
    def __init__(self, node_id: str):
        self.node_id = node_id
        self.process = psutil.Process()
        self.redis_client = redis.Redis()
        self.memory_threshold = 75.0
    
    def get_memory_status(self) -> dict:
        """获取当前节点内存状态"""
        memory_usage = self.process.memory_percent()
        return {
            'node_id': self.node_id,
            'memory_usage': memory_usage,
            'memory_mb': self.process.memory_info().rss / 1024 / 1024,
            'status': 'warning' if memory_usage > self.memory_threshold else 'normal',
            'timestamp': time.time()
        }
    
    async def report_memory_status(self):
        """向中心节点报告内存状态"""
        status = self.get_memory_status()
        await self.redis_client.hset(
            'memory_status',
            self.node_id,
            json.dumps(status)
        )
    
    async def check_cluster_memory(self):
        """检查集群内存状态"""
        all_status = await self.redis_client.hgetall('memory_status')
        total_memory = 0
        warning_nodes = []
        
        for node_id, status_json in all_status.items():
            status = json.loads(status_json)
            total_memory += status['memory_usage']
            if status['status'] == 'warning':
                warning_nodes.append(node_id)
        
        avg_memory = total_memory / len(all_status) if all_status else 0
        
        return {
            'average_memory': avg_memory,
            'warning_nodes': warning_nodes,
            'total_nodes': len(all_status)
        }
```

### 2. 跨节点资源调度
```python
# 跨节点资源调度器
class ResourceScheduler:
    def __init__(self):
        self.redis_client = redis.Redis()
        self.load_balancer = LoadBalancer()
    
    async def schedule_task(self, task_type: str, task_data: dict) -> str:
        """调度任务到最适合的节点"""
        # 获取所有节点状态
        node_statuses = await self.get_all_node_statuses()
        
        # 选择内存使用率最低的节点
        best_node = self.select_best_node(node_statuses, task_type)
        
        if best_node:
            # 分配任务到选中的节点
            task_id = await self.assign_task_to_node(best_node, task_type, task_data)
            return task_id
        else:
            # 所有节点都过载，拒绝任务
            raise ResourceExhaustedError("所有节点都过载，无法分配任务")
    
    def select_best_node(self, node_statuses: list, task_type: str) -> str:
        """选择最适合的节点"""
        available_nodes = []
        
        for node in node_statuses:
            if node['memory_usage'] < 75.0:  # 内存使用率低于75%
                available_nodes.append(node)
        
        if not available_nodes:
            return None
        
        # 按内存使用率排序，选择最低的
        available_nodes.sort(key=lambda x: x['memory_usage'])
        return available_nodes[0]['node_id']
    
    async def rebalance_cluster(self):
        """重新平衡集群负载"""
        node_statuses = await self.get_all_node_statuses()
        
        # 找出过载和空闲的节点
        overloaded_nodes = [n for n in node_statuses if n['memory_usage'] > 80.0]
        idle_nodes = [n for n in node_statuses if n['memory_usage'] < 50.0]
        
        if overloaded_nodes and idle_nodes:
            # 从过载节点迁移任务到空闲节点
            await self.migrate_tasks(overloaded_nodes, idle_nodes)
```

### 3. 流量分析内存优化
```python
# Suricata内存优化配置
SURICATA_MEMORY_CONFIG = {
    "max_memory": "2GB",              # 最大内存使用
    "memory_policy": "allkeys-lru",   # 内存策略
    "max_flow_memory": "1GB",         # 流内存限制
    "max_packet_memory": "512MB",     # 包内存限制
    "worker_memory_limit": "256MB",   # 工作进程内存限制
    "rule_memory_limit": "128MB"      # 规则内存限制
}

# 流量分析内存管理
class TrafficAnalyzerMemoryManager:
    def __init__(self):
        self.suricata_process = None
        self.memory_monitor = MemoryMonitor()
    
    def configure_suricata_memory(self):
        """配置Suricata内存限制"""
        suricata_config = {
            'max_memory': SURICATA_MEMORY_CONFIG['max_memory'],
            'memory_policy': SURICATA_MEMORY_CONFIG['memory_policy'],
            'max_flow_memory': SURICATA_MEMORY_CONFIG['max_flow_memory'],
            'max_packet_memory': SURICATA_MEMORY_CONFIG['max_packet_memory']
        }
        
        # 更新Suricata配置
        self.update_suricata_config(suricata_config)
    
    def monitor_suricata_memory(self):
        """监控Suricata内存使用"""
        if self.suricata_process:
            memory_usage = self.suricata_process.memory_percent()
            
            if memory_usage > 80.0:
                # 内存使用过高，重启Suricata
                self.restart_suricata()
            elif memory_usage > 60.0:
                # 内存使用较高，清理缓存
                self.cleanup_suricata_cache()
    
    def cleanup_suricata_cache(self):
        """清理Suricata缓存"""
        try:
            # 发送清理命令到Suricata
            subprocess.run(['suricata', '--cleanup-cache'], timeout=30)
            logger.info("Suricata缓存清理完成")
        except Exception as e:
            logger.error(f"Suricata缓存清理失败: {e}")
```

### 4. 子域名扫描内存优化
```python
# 子域名扫描内存管理
class SubdomainScannerMemoryManager:
    def __init__(self, max_concurrent_scans=10):
        self.max_concurrent_scans = max_concurrent_scans
        self.active_scans = {}
        self.semaphore = asyncio.Semaphore(max_concurrent_scans)
    
    async def scan_with_memory_control(self, domain: str) -> list:
        """带内存控制的子域名扫描"""
        async with self.semaphore:
            # 检查内存使用
            if not self.check_memory_safe():
                await self.wait_for_memory()
            
            # 注册扫描任务
            scan_id = f"scan_{domain}_{int(time.time())}"
            self.active_scans[scan_id] = {
                'domain': domain,
                'start_time': time.time(),
                'memory_usage': psutil.Process().memory_percent()
            }
            
            try:
                # 执行扫描
                subdomains = await self.perform_scan(domain)
                return subdomains
            finally:
                # 清理扫描任务
                if scan_id in self.active_scans:
                    del self.active_scans[scan_id]
    
    def check_memory_safe(self) -> bool:
        """检查内存是否安全"""
        return psutil.Process().memory_percent() < 75.0
    
    async def wait_for_memory(self, timeout=60):
        """等待内存释放"""
        start_time = time.time()
        while not self.check_memory_safe() and (time.time() - start_time) < timeout:
            # 强制垃圾回收
            gc.collect()
            await asyncio.sleep(5)
        
        if not self.check_memory_safe():
            raise MemoryError("内存不足，无法执行扫描")
```

### 5. 风险控制措施
- **分布式监控**：实时监控所有节点的内存使用情况
- **自动负载均衡**：根据内存使用情况自动分配任务
- **资源隔离**：不同服务使用独立的内存空间
- **优雅降级**：内存不足时自动降低处理能力
- **快速恢复**：内存释放后自动恢复正常处理能力