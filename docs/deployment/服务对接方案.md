# RegScan 微服务对接方案

## 项目概述

本项目是一个内容合规检测系统，采用微服务架构，包含以下核心模块：

- **config-manager**: 配置管理服务 (端口: 8000)
- **website-scanner**: 网站扫描服务 (端口: 8001) 
- **alert-handler**: 告警处理服务 (端口: 8002)
- **task-scheduler**: 任务调度服务 (Celery)
- **web-admin**: 前端管理界面 (端口: 3000)

## 当前状态分析

### 已完成模块
✅ **config-manager**: 配置管理API已完成，数据库正常运行  
✅ **website-scanner**: 扫描服务核心功能已实现  
✅ **alert-handler**: 告警处理系统已完成企业级重构  
✅ **task-scheduler**: Celery任务调度框架已搭建  
⚠️ **web-admin**: 前端框架已搭建，但API对接不完整  

### 需要对接的问题
1. 前端API调用配置不完整
2. 服务间通信接口需要统一
3. 缺少服务发现和负载均衡
4. 错误处理和重试机制需要完善

## 服务对接架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        前端层 (web-admin)                       │
│                     http://localhost:3000                      │
└─────────────────────┬───────────────────────────────────────────┘
                      │ HTTP/REST API
┌─────────────────────▼───────────────────────────────────────────┐
│                        API网关层                                │
│                   (Nginx/Kong - 可选)                          │
└─────────────────────┬───────────────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────────────┐
│                      微服务层                                   │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  │
│  │ config-manager  │  │ website-scanner │  │ alert-handler   │  │
│  │   :8000         │  │     :8001       │  │     :8002       │  │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘  │
│                           │                                     │
│  ┌─────────────────────────▼─────────────────────────────────┐  │
│  │              task-scheduler (Celery)                     │  │
│  │         RabbitMQ + Redis + Worker Processes              │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

## 详细对接方案

### 1. 前端API对接配置

#### 1.1 更新API配置文件

需要完善 `web-admin/src/api/` 目录下的API调用文件：

**scanner.js** - 扫描服务API
```javascript
import request from '@/utils/request'
import { API_BASE_URLS } from './config'

// 创建扫描任务
export function createScanTask(data) {
  return request({
    url: `${API_BASE_URLS.SCANNER}/scan/${data.domain}`,
    method: 'post',
    data
  })
}

// 获取扫描结果
export function getScanResults(params) {
  return request({
    url: `${API_BASE_URLS.SCANNER}/results`,
    method: 'get',
    params
  })
}

// 获取扫描历史
export function getScanHistory(params) {
  return request({
    url: `${API_BASE_URLS.SCANNER}/results/history`,
    method: 'get',
    params
  })
}
```

**alerts.js** - 告警服务API
```javascript
import request from '@/utils/request'
import { API_BASE_URLS } from './config'

// 获取告警列表
export function getAlerts(params) {
  return request({
    url: `${API_BASE_URLS.ALERTS}/alerts`,
    method: 'get',
    params
  })
}

// 创建告警
export function createAlert(data) {
  return request({
    url: `${API_BASE_URLS.ALERTS}/alerts`,
    method: 'post',
    data
  })
}

// 更新告警状态
export function updateAlert(alertId, data) {
  return request({
    url: `${API_BASE_URLS.ALERTS}/alerts/${alertId}`,
    method: 'put',
    data
  })
}

// 获取告警统计
export function getAlertStatistics(params) {
  return request({
    url: `${API_BASE_URLS.ALERTS}/alerts/statistics/overview`,
    method: 'get',
    params
  })
}
```

#### 1.2 更新请求工具配置

修改 `web-admin/src/utils/request.js` 支持多服务调用：

```javascript
import axios from 'axios'
import { ElMessage } from 'element-plus'
import { API_BASE_URLS } from '@/api/config'

// 创建不同服务的axios实例
const createServiceRequest = (baseURL) => {
  const instance = axios.create({
    baseURL,
    timeout: 10000,
    headers: {
      'Content-Type': 'application/json'
    }
  })
  
  // 添加通用拦截器
  instance.interceptors.request.use(config => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  })
  
  instance.interceptors.response.use(
    response => response.data,
    error => {
      ElMessage.error(error.response?.data?.message || '请求失败')
      return Promise.reject(error)
    }
  )
  
  return instance
}

// 导出各服务的请求实例
export const configRequest = createServiceRequest(API_BASE_URLS.CONFIG)
export const scannerRequest = createServiceRequest(API_BASE_URLS.SCANNER)
export const alertsRequest = createServiceRequest(API_BASE_URLS.ALERTS)

export default configRequest // 默认使用配置服务
```

### 2. 服务间通信接口

#### 2.1 扫描服务 → 告警服务

当扫描发现违规内容时，需要自动创建告警：

**website-scanner/app/services/scan_service.py**
```python
import httpx
import asyncio
from typing import Dict, Any

class ScanService:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.alert_service_url = "http://localhost:8002/api/v1"
    
    async def create_alert_for_violation(self, scan_result: Dict[str, Any]):
        """为违规内容创建告警"""
        alert_data = {
            "source_module": "website-scanner",
            "target_url": scan_result.get("url"),
            "domain": scan_result.get("domain"),
            "alert_type": "content_violation",
            "severity": self._determine_severity(scan_result),
            "title": f"检测到违规内容: {scan_result.get('domain')}",
            "description": f"在 {scan_result.get('url')} 发现违规内容",
            "evidence": {
                "violation_type": scan_result.get("violation_type"),
                "confidence": scan_result.get("confidence"),
                "content_snippet": scan_result.get("content_snippet")
            },
            "priority": 2 if scan_result.get("confidence", 0) > 0.8 else 3
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.alert_service_url}/alerts",
                    json=alert_data,
                    timeout=10.0
                )
                response.raise_for_status()
                return response.json()
        except Exception as e:
            print(f"Failed to create alert: {e}")
            return None
    
    def _determine_severity(self, scan_result: Dict[str, Any]) -> str:
        """根据扫描结果确定告警严重级别"""
        confidence = scan_result.get("confidence", 0)
        violation_type = scan_result.get("violation_type", "")
        
        if confidence > 0.9 or "illegal" in violation_type.lower():
            return "critical"
        elif confidence > 0.7:
            return "high"
        elif confidence > 0.5:
            return "medium"
        else:
            return "low"
```

#### 2.2 告警服务 → 任务调度服务

告警处理完成后，需要通知任务调度服务更新相关任务状态：

**alert-handler/app/services/alert_processor.py**
```python
from celery import Celery
from ..tasks.alert_tasks import notify_task_scheduler

class AlertProcessorService:
    def __init__(self):
        self.celery_app = Celery('alert_handler')
    
    async def process_alert_resolution(self, alert_id: str, resolution_data: Dict[str, Any]):
        """处理告警解决后的后续任务"""
        # 异步通知任务调度服务
        notify_task_scheduler.delay({
            "alert_id": alert_id,
            "action": "alert_resolved",
            "data": resolution_data
        })
```

#### 2.3 配置服务集成

所有服务都应该从配置服务获取配置信息：

**共用配置客户端 (utils/config_client.py)**
```python
import httpx
import asyncio
from typing import Dict, Any, Optional

class ConfigClient:
    def __init__(self, config_service_url: str = "http://localhost:8000"):
        self.base_url = config_service_url
        self._cache = {}
        self._cache_ttl = 300  # 5分钟缓存
    
    async def get_config(self, key: str, default: Any = None) -> Any:
        """获取配置项"""
        if key in self._cache:
            return self._cache[key]
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.base_url}/api/v1/configs",
                    params={"key": key}
                )
                response.raise_for_status()
                data = response.json()
                
                if data and len(data) > 0:
                    value = data[0].get("value", default)
                    self._cache[key] = value
                    return value
                    
        except Exception as e:
            print(f"Failed to get config {key}: {e}")
        
        return default
    
    async def update_config(self, key: str, value: Any) -> bool:
        """更新配置项"""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.base_url}/api/v1/configs",
                    json={
                        "key": key,
                        "value": str(value),
                        "category": "system",
                        "environment": "production"
                    }
                )
                response.raise_for_status()
                # 清除缓存
                self._cache.pop(key, None)
                return True
        except Exception as e:
            print(f"Failed to update config {key}: {e}")
            return False

# 全局配置客户端实例
config_client = ConfigClient()
```

### 3. 服务启动脚本

创建统一的服务启动脚本 `scripts/start_all_services.py`：

```python
#!/usr/bin/env python3
import subprocess
import time
import sys
import os
from pathlib import Path

# 项目根目录
PROJECT_ROOT = Path(__file__).parent.parent

# 服务配置
SERVICES = [
    {
        "name": "config-manager",
        "cmd": ["python", "-m", "uvicorn", "app.main:app", "--reload", "--host", "0.0.0.0", "--port", "8000"],
        "cwd": PROJECT_ROOT / "config-manager",
        "port": 8000
    },
    {
        "name": "website-scanner", 
        "cmd": ["python", "-m", "uvicorn", "app.main:app", "--reload", "--host", "0.0.0.0", "--port", "8001"],
        "cwd": PROJECT_ROOT / "website-scanner",
        "port": 8001
    },
    {
        "name": "alert-handler",
        "cmd": ["python", "-m", "uvicorn", "app.main:app", "--reload", "--host", "0.0.0.0", "--port", "8002"],
        "cwd": PROJECT_ROOT / "alert-handler", 
        "port": 8002
    },
    {
        "name": "task-scheduler-worker",
        "cmd": ["celery", "-A", "app.celery_app", "worker", "--loglevel=info"],
        "cwd": PROJECT_ROOT / "task-scheduler",
        "port": None
    },
    {
        "name": "task-scheduler-beat",
        "cmd": ["celery", "-A", "app.celery_app", "beat", "--loglevel=info"],
        "cwd": PROJECT_ROOT / "task-scheduler",
        "port": None
    }
]

def start_service(service):
    """启动单个服务"""
    print(f"Starting {service['name']}...")
    try:
        process = subprocess.Popen(
            service["cmd"],
            cwd=service["cwd"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        return process
    except Exception as e:
        print(f"Failed to start {service['name']}: {e}")
        return None

def check_service_health(port):
    """检查服务健康状态"""
    if port is None:
        return True
    
    import requests
    try:
        response = requests.get(f"http://localhost:{port}/health", timeout=5)
        return response.status_code == 200
    except:
        return False

def main():
    """启动所有服务"""
    print("Starting all microservices...")
    
    processes = []
    
    # 启动所有服务
    for service in SERVICES:
        process = start_service(service)
        if process:
            processes.append((service, process))
            time.sleep(2)  # 等待服务启动
    
    # 等待服务就绪
    print("Waiting for services to be ready...")
    time.sleep(10)
    
    # 检查服务健康状态
    for service, process in processes:
        if service["port"]:
            if check_service_health(service["port"]):
                print(f"✅ {service['name']} is healthy")
            else:
                print(f"❌ {service['name']} is not responding")
        else:
            print(f"ℹ️  {service['name']} started (no health check)")
    
    print("\n🚀 All services started!")
    print("\nService URLs:")
    print("- Config Manager: http://localhost:8000")
    print("- Website Scanner: http://localhost:8001")
    print("- Alert Handler: http://localhost:8002")
    print("- Web Admin: http://localhost:3000 (start separately)")
    
    try:
        # 保持脚本运行
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\nShutting down services...")
        for service, process in processes:
            process.terminate()
        print("All services stopped.")

if __name__ == "__main__":
    main()
```

### 4. Docker Compose 集成部署

创建根目录下的 `docker-compose.yml`：

```yaml
version: '3.8'

services:
  # 数据库服务
  mongodb:
    image: mongo:5.0
    container_name: mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGODB_USERNAME}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGODB_PASSWORD}
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    container_name: redis
    restart: unless-stopped
    command: redis-server --requirepass ${REDIS_PASSWORD}
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - app-network

  rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq
    restart: unless-stopped
    environment:
      RABBITMQ_DEFAULT_USER: admin
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}
    ports:
      - "5672:5672"
      - "15672:15672"
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    networks:
      - app-network

  # 微服务
  config-manager:
    build: ./config-manager
    container_name: config-manager
    restart: unless-stopped
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=sqlite:///./data/config.db
      - SECRET_KEY=${SECRET_KEY}
    volumes:
      - ./config-manager/data:/app/data
    networks:
      - app-network
    depends_on:
      - mongodb
      - redis

  website-scanner:
    build: ./website-scanner
    container_name: website-scanner
    restart: unless-stopped
    ports:
      - "8001:8001"
    environment:
      - MONGODB_URL=mongodb://${MONGODB_USERNAME}:${MONGODB_PASSWORD}@mongodb:27017
      - CONTENT_API_KEY=${CONTENT_API_KEY}
    networks:
      - app-network
    depends_on:
      - mongodb
      - config-manager

  alert-handler:
    build: ./alert-handler
    container_name: alert-handler
    restart: unless-stopped
    ports:
      - "8002:8002"
    environment:
      - DATABASE_URL=postgresql://${POSTGRES_USERNAME}:${POSTGRES_PASSWORD}@postgres:5432/alerts
      - CELERY_BROKER_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
      - EMAIL_API_KEY=${EMAIL_API_KEY}
      - SMS_API_KEY=${SMS_API_KEY}
    networks:
      - app-network
    depends_on:
      - redis
      - rabbitmq
      - config-manager

  task-scheduler:
    build: ./task-scheduler
    container_name: task-scheduler
    restart: unless-stopped
    environment:
      - CELERY_BROKER_URL=amqp://admin:${RABBITMQ_PASSWORD}@rabbitmq:5672//
      - CELERY_RESULT_BACKEND=redis://:${REDIS_PASSWORD}@redis:6379/1
    networks:
      - app-network
    depends_on:
      - rabbitmq
      - redis

  web-admin:
    build: ./web-admin
    container_name: web-admin
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - VUE_APP_API_BASE_URL=http://localhost:8000
    networks:
      - app-network
    depends_on:
      - config-manager
      - website-scanner
      - alert-handler

volumes:
  mongodb_data:
  redis_data:
  rabbitmq_data:

networks:
  app-network:
    driver: bridge
```

## 对接测试方案

### 1. 单元测试

每个服务都应该有完整的API测试：

**tests/integration/test_service_integration.py**
```python
import pytest
import httpx
import asyncio

class TestServiceIntegration:
    
    @pytest.mark.asyncio
    async def test_config_to_scanner_integration(self):
        """测试配置服务到扫描服务的集成"""
        # 1. 从配置服务获取扫描配置
        async with httpx.AsyncClient() as client:
            config_response = await client.get(
                "http://localhost:8000/api/v1/configs",
                params={"category": "scanner"}
            )
            assert config_response.status_code == 200
            
            # 2. 使用配置启动扫描任务
            scan_response = await client.post(
                "http://localhost:8001/api/v1/scan/example.com"
            )
            assert scan_response.status_code == 200
    
    @pytest.mark.asyncio
    async def test_scanner_to_alert_integration(self):
        """测试扫描服务到告警服务的集成"""
        # 模拟扫描发现违规内容，自动创建告警
        async with httpx.AsyncClient() as client:
            # 1. 创建告警
            alert_data = {
                "source_module": "website-scanner",
                "target_url": "http://example.com",
                "alert_type": "content_violation",
                "severity": "high",
                "title": "测试告警",
                "description": "集成测试告警"
            }
            
            alert_response = await client.post(
                "http://localhost:8002/api/v1/alerts",
                json=alert_data
            )
            assert alert_response.status_code == 200
            
            # 2. 验证告警已创建
            alerts_response = await client.get(
                "http://localhost:8002/api/v1/alerts"
            )
            assert alerts_response.status_code == 200
            alerts = alerts_response.json()
            assert len(alerts["alerts"]) > 0
```

### 2. 端到端测试

**tests/e2e/test_full_workflow.py**
```python
import pytest
import httpx
import asyncio
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

class TestFullWorkflow:
    
    @pytest.mark.asyncio
    async def test_complete_scan_workflow(self):
        """测试完整的扫描工作流程"""
        # 1. 通过前端创建扫描任务
        driver = webdriver.Chrome()
        try:
            driver.get("http://localhost:3000")
            
            # 导航到扫描管理页面
            scan_menu = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.LINK_TEXT, "扫描管理"))
            )
            scan_menu.click()
            
            # 输入域名并启动扫描
            domain_input = driver.find_element(By.NAME, "domain")
            domain_input.send_keys("example.com")
            
            start_button = driver.find_element(By.BUTTON, "开始扫描")
            start_button.click()
            
            # 2. 验证后端API调用
            async with httpx.AsyncClient() as client:
                # 检查扫描任务是否创建
                response = await client.get(
                    "http://localhost:8001/api/v1/results",
                    params={"domain": "example.com"}
                )
                assert response.status_code == 200
                
        finally:
            driver.quit()
```

## 部署和运维

### 1. 环境配置

复制并配置环境变量：
```bash
cp env.example .env
# 编辑 .env 文件，填入实际配置
```

### 2. 启动服务

**开发环境：**
```bash
# 启动后端服务
python scripts/start_all_services.py

# 启动前端服务
cd web-admin
npm install
npm run dev
```

**生产环境：**
```bash
# 使用Docker Compose
docker-compose up -d
```

### 3. 健康检查

创建健康检查脚本 `scripts/health_check.py`：

```python
import httpx
import asyncio

SERVICES = [
    {"name": "Config Manager", "url": "http://localhost:8000/health"},
    {"name": "Website Scanner", "url": "http://localhost:8001/health"},
    {"name": "Alert Handler", "url": "http://localhost:8002/health"},
]

async def check_service(service):
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(service["url"], timeout=5)
            if response.status_code == 200:
                print(f"✅ {service['name']}: OK")
                return True
            else:
                print(f"❌ {service['name']}: HTTP {response.status_code}")
                return False
    except Exception as e:
        print(f"❌ {service['name']}: {str(e)}")
        return False

async def main():
    print("Checking service health...")
    results = await asyncio.gather(*[check_service(s) for s in SERVICES])
    
    healthy_count = sum(results)
    total_count = len(SERVICES)
    
    print(f"\nHealth check complete: {healthy_count}/{total_count} services healthy")
    
    if healthy_count == total_count:
        print("🎉 All services are healthy!")
        return 0
    else:
        print("⚠️  Some services are not healthy")
        return 1

if __name__ == "__main__":
    exit(asyncio.run(main()))
```

## 总结

本对接方案提供了：

1. **完整的API对接配置** - 前端到各个微服务的API调用
2. **服务间通信机制** - 微服务之间的数据交换和事件通知
3. **统一配置管理** - 所有服务从配置中心获取配置
4. **容器化部署方案** - Docker Compose 一键部署
5. **测试和监控** - 集成测试和健康检查机制

通过这个方案，可以实现各个微服务的完整对接，确保系统的稳定运行和可维护性。