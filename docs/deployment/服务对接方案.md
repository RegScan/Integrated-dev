# RegScan å¾®æœåŠ¡å¯¹æ¥æ–¹æ¡ˆ

## é¡¹ç›®æ¦‚è¿°

æœ¬é¡¹ç›®æ˜¯ä¸€ä¸ªå†…å®¹åˆè§„æ£€æµ‹ç³»ç»Ÿï¼Œé‡‡ç”¨å¾®æœåŠ¡æ¶æ„ï¼ŒåŒ…å«ä»¥ä¸‹æ ¸å¿ƒæ¨¡å—ï¼š

- **config-manager**: é…ç½®ç®¡ç†æœåŠ¡ (ç«¯å£: 8000)
- **website-scanner**: ç½‘ç«™æ‰«ææœåŠ¡ (ç«¯å£: 8001) 
- **alert-handler**: å‘Šè­¦å¤„ç†æœåŠ¡ (ç«¯å£: 8002)
- **task-scheduler**: ä»»åŠ¡è°ƒåº¦æœåŠ¡ (Celery)
- **web-admin**: å‰ç«¯ç®¡ç†ç•Œé¢ (ç«¯å£: 3000)

## å½“å‰çŠ¶æ€åˆ†æ

### å·²å®Œæˆæ¨¡å—
âœ… **config-manager**: é…ç½®ç®¡ç†APIå·²å®Œæˆï¼Œæ•°æ®åº“æ­£å¸¸è¿è¡Œ  
âœ… **website-scanner**: æ‰«ææœåŠ¡æ ¸å¿ƒåŠŸèƒ½å·²å®ç°  
âœ… **alert-handler**: å‘Šè­¦å¤„ç†ç³»ç»Ÿå·²å®Œæˆä¼ä¸šçº§é‡æ„  
âœ… **task-scheduler**: Celeryä»»åŠ¡è°ƒåº¦æ¡†æ¶å·²æ­å»º  
âš ï¸ **web-admin**: å‰ç«¯æ¡†æ¶å·²æ­å»ºï¼Œä½†APIå¯¹æ¥ä¸å®Œæ•´  

### éœ€è¦å¯¹æ¥çš„é—®é¢˜
1. å‰ç«¯APIè°ƒç”¨é…ç½®ä¸å®Œæ•´
2. æœåŠ¡é—´é€šä¿¡æ¥å£éœ€è¦ç»Ÿä¸€
3. ç¼ºå°‘æœåŠ¡å‘ç°å’Œè´Ÿè½½å‡è¡¡
4. é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶éœ€è¦å®Œå–„

## æœåŠ¡å¯¹æ¥æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å‰ç«¯å±‚ (web-admin)                       â”‚
â”‚                     http://localhost:3000                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ HTTP/REST API
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        APIç½‘å…³å±‚                                â”‚
â”‚                   (Nginx/Kong - å¯é€‰)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      å¾®æœåŠ¡å±‚                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ config-manager  â”‚  â”‚ website-scanner â”‚  â”‚ alert-handler   â”‚  â”‚
â”‚  â”‚   :8000         â”‚  â”‚     :8001       â”‚  â”‚     :8002       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                           â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              task-scheduler (Celery)                     â”‚  â”‚
â”‚  â”‚         RabbitMQ + Redis + Worker Processes              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## è¯¦ç»†å¯¹æ¥æ–¹æ¡ˆ

### 1. å‰ç«¯APIå¯¹æ¥é…ç½®

#### 1.1 æ›´æ–°APIé…ç½®æ–‡ä»¶

éœ€è¦å®Œå–„ `web-admin/src/api/` ç›®å½•ä¸‹çš„APIè°ƒç”¨æ–‡ä»¶ï¼š

**scanner.js** - æ‰«ææœåŠ¡API
```javascript
import request from '@/utils/request'
import { API_BASE_URLS } from './config'

// åˆ›å»ºæ‰«æä»»åŠ¡
export function createScanTask(data) {
  return request({
    url: `${API_BASE_URLS.SCANNER}/scan/${data.domain}`,
    method: 'post',
    data
  })
}

// è·å–æ‰«æç»“æœ
export function getScanResults(params) {
  return request({
    url: `${API_BASE_URLS.SCANNER}/results`,
    method: 'get',
    params
  })
}

// è·å–æ‰«æå†å²
export function getScanHistory(params) {
  return request({
    url: `${API_BASE_URLS.SCANNER}/results/history`,
    method: 'get',
    params
  })
}
```

**alerts.js** - å‘Šè­¦æœåŠ¡API
```javascript
import request from '@/utils/request'
import { API_BASE_URLS } from './config'

// è·å–å‘Šè­¦åˆ—è¡¨
export function getAlerts(params) {
  return request({
    url: `${API_BASE_URLS.ALERTS}/alerts`,
    method: 'get',
    params
  })
}

// åˆ›å»ºå‘Šè­¦
export function createAlert(data) {
  return request({
    url: `${API_BASE_URLS.ALERTS}/alerts`,
    method: 'post',
    data
  })
}

// æ›´æ–°å‘Šè­¦çŠ¶æ€
export function updateAlert(alertId, data) {
  return request({
    url: `${API_BASE_URLS.ALERTS}/alerts/${alertId}`,
    method: 'put',
    data
  })
}

// è·å–å‘Šè­¦ç»Ÿè®¡
export function getAlertStatistics(params) {
  return request({
    url: `${API_BASE_URLS.ALERTS}/alerts/statistics/overview`,
    method: 'get',
    params
  })
}
```

#### 1.2 æ›´æ–°è¯·æ±‚å·¥å…·é…ç½®

ä¿®æ”¹ `web-admin/src/utils/request.js` æ”¯æŒå¤šæœåŠ¡è°ƒç”¨ï¼š

```javascript
import axios from 'axios'
import { ElMessage } from 'element-plus'
import { API_BASE_URLS } from '@/api/config'

// åˆ›å»ºä¸åŒæœåŠ¡çš„axioså®ä¾‹
const createServiceRequest = (baseURL) => {
  const instance = axios.create({
    baseURL,
    timeout: 10000,
    headers: {
      'Content-Type': 'application/json'
    }
  })
  
  // æ·»åŠ é€šç”¨æ‹¦æˆªå™¨
  instance.interceptors.request.use(config => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  })
  
  instance.interceptors.response.use(
    response => response.data,
    error => {
      ElMessage.error(error.response?.data?.message || 'è¯·æ±‚å¤±è´¥')
      return Promise.reject(error)
    }
  )
  
  return instance
}

// å¯¼å‡ºå„æœåŠ¡çš„è¯·æ±‚å®ä¾‹
export const configRequest = createServiceRequest(API_BASE_URLS.CONFIG)
export const scannerRequest = createServiceRequest(API_BASE_URLS.SCANNER)
export const alertsRequest = createServiceRequest(API_BASE_URLS.ALERTS)

export default configRequest // é»˜è®¤ä½¿ç”¨é…ç½®æœåŠ¡
```

### 2. æœåŠ¡é—´é€šä¿¡æ¥å£

#### 2.1 æ‰«ææœåŠ¡ â†’ å‘Šè­¦æœåŠ¡

å½“æ‰«æå‘ç°è¿è§„å†…å®¹æ—¶ï¼Œéœ€è¦è‡ªåŠ¨åˆ›å»ºå‘Šè­¦ï¼š

**website-scanner/app/services/scan_service.py**
```python
import httpx
import asyncio
from typing import Dict, Any

class ScanService:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.alert_service_url = "http://localhost:8002/api/v1"
    
    async def create_alert_for_violation(self, scan_result: Dict[str, Any]):
        """ä¸ºè¿è§„å†…å®¹åˆ›å»ºå‘Šè­¦"""
        alert_data = {
            "source_module": "website-scanner",
            "target_url": scan_result.get("url"),
            "domain": scan_result.get("domain"),
            "alert_type": "content_violation",
            "severity": self._determine_severity(scan_result),
            "title": f"æ£€æµ‹åˆ°è¿è§„å†…å®¹: {scan_result.get('domain')}",
            "description": f"åœ¨ {scan_result.get('url')} å‘ç°è¿è§„å†…å®¹",
            "evidence": {
                "violation_type": scan_result.get("violation_type"),
                "confidence": scan_result.get("confidence"),
                "content_snippet": scan_result.get("content_snippet")
            },
            "priority": 2 if scan_result.get("confidence", 0) > 0.8 else 3
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.alert_service_url}/alerts",
                    json=alert_data,
                    timeout=10.0
                )
                response.raise_for_status()
                return response.json()
        except Exception as e:
            print(f"Failed to create alert: {e}")
            return None
    
    def _determine_severity(self, scan_result: Dict[str, Any]) -> str:
        """æ ¹æ®æ‰«æç»“æœç¡®å®šå‘Šè­¦ä¸¥é‡çº§åˆ«"""
        confidence = scan_result.get("confidence", 0)
        violation_type = scan_result.get("violation_type", "")
        
        if confidence > 0.9 or "illegal" in violation_type.lower():
            return "critical"
        elif confidence > 0.7:
            return "high"
        elif confidence > 0.5:
            return "medium"
        else:
            return "low"
```

#### 2.2 å‘Šè­¦æœåŠ¡ â†’ ä»»åŠ¡è°ƒåº¦æœåŠ¡

å‘Šè­¦å¤„ç†å®Œæˆåï¼Œéœ€è¦é€šçŸ¥ä»»åŠ¡è°ƒåº¦æœåŠ¡æ›´æ–°ç›¸å…³ä»»åŠ¡çŠ¶æ€ï¼š

**alert-handler/app/services/alert_processor.py**
```python
from celery import Celery
from ..tasks.alert_tasks import notify_task_scheduler

class AlertProcessorService:
    def __init__(self):
        self.celery_app = Celery('alert_handler')
    
    async def process_alert_resolution(self, alert_id: str, resolution_data: Dict[str, Any]):
        """å¤„ç†å‘Šè­¦è§£å†³åçš„åç»­ä»»åŠ¡"""
        # å¼‚æ­¥é€šçŸ¥ä»»åŠ¡è°ƒåº¦æœåŠ¡
        notify_task_scheduler.delay({
            "alert_id": alert_id,
            "action": "alert_resolved",
            "data": resolution_data
        })
```

#### 2.3 é…ç½®æœåŠ¡é›†æˆ

æ‰€æœ‰æœåŠ¡éƒ½åº”è¯¥ä»é…ç½®æœåŠ¡è·å–é…ç½®ä¿¡æ¯ï¼š

**å…±ç”¨é…ç½®å®¢æˆ·ç«¯ (utils/config_client.py)**
```python
import httpx
import asyncio
from typing import Dict, Any, Optional

class ConfigClient:
    def __init__(self, config_service_url: str = "http://localhost:8000"):
        self.base_url = config_service_url
        self._cache = {}
        self._cache_ttl = 300  # 5åˆ†é’Ÿç¼“å­˜
    
    async def get_config(self, key: str, default: Any = None) -> Any:
        """è·å–é…ç½®é¡¹"""
        if key in self._cache:
            return self._cache[key]
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.base_url}/api/v1/configs",
                    params={"key": key}
                )
                response.raise_for_status()
                data = response.json()
                
                if data and len(data) > 0:
                    value = data[0].get("value", default)
                    self._cache[key] = value
                    return value
                    
        except Exception as e:
            print(f"Failed to get config {key}: {e}")
        
        return default
    
    async def update_config(self, key: str, value: Any) -> bool:
        """æ›´æ–°é…ç½®é¡¹"""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.base_url}/api/v1/configs",
                    json={
                        "key": key,
                        "value": str(value),
                        "category": "system",
                        "environment": "production"
                    }
                )
                response.raise_for_status()
                # æ¸…é™¤ç¼“å­˜
                self._cache.pop(key, None)
                return True
        except Exception as e:
            print(f"Failed to update config {key}: {e}")
            return False

# å…¨å±€é…ç½®å®¢æˆ·ç«¯å®ä¾‹
config_client = ConfigClient()
```

### 3. æœåŠ¡å¯åŠ¨è„šæœ¬

åˆ›å»ºç»Ÿä¸€çš„æœåŠ¡å¯åŠ¨è„šæœ¬ `scripts/start_all_services.py`ï¼š

```python
#!/usr/bin/env python3
import subprocess
import time
import sys
import os
from pathlib import Path

# é¡¹ç›®æ ¹ç›®å½•
PROJECT_ROOT = Path(__file__).parent.parent

# æœåŠ¡é…ç½®
SERVICES = [
    {
        "name": "config-manager",
        "cmd": ["python", "-m", "uvicorn", "app.main:app", "--reload", "--host", "0.0.0.0", "--port", "8000"],
        "cwd": PROJECT_ROOT / "config-manager",
        "port": 8000
    },
    {
        "name": "website-scanner", 
        "cmd": ["python", "-m", "uvicorn", "app.main:app", "--reload", "--host", "0.0.0.0", "--port", "8001"],
        "cwd": PROJECT_ROOT / "website-scanner",
        "port": 8001
    },
    {
        "name": "alert-handler",
        "cmd": ["python", "-m", "uvicorn", "app.main:app", "--reload", "--host", "0.0.0.0", "--port", "8002"],
        "cwd": PROJECT_ROOT / "alert-handler", 
        "port": 8002
    },
    {
        "name": "task-scheduler-worker",
        "cmd": ["celery", "-A", "app.celery_app", "worker", "--loglevel=info"],
        "cwd": PROJECT_ROOT / "task-scheduler",
        "port": None
    },
    {
        "name": "task-scheduler-beat",
        "cmd": ["celery", "-A", "app.celery_app", "beat", "--loglevel=info"],
        "cwd": PROJECT_ROOT / "task-scheduler",
        "port": None
    }
]

def start_service(service):
    """å¯åŠ¨å•ä¸ªæœåŠ¡"""
    print(f"Starting {service['name']}...")
    try:
        process = subprocess.Popen(
            service["cmd"],
            cwd=service["cwd"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        return process
    except Exception as e:
        print(f"Failed to start {service['name']}: {e}")
        return None

def check_service_health(port):
    """æ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€"""
    if port is None:
        return True
    
    import requests
    try:
        response = requests.get(f"http://localhost:{port}/health", timeout=5)
        return response.status_code == 200
    except:
        return False

def main():
    """å¯åŠ¨æ‰€æœ‰æœåŠ¡"""
    print("Starting all microservices...")
    
    processes = []
    
    # å¯åŠ¨æ‰€æœ‰æœåŠ¡
    for service in SERVICES:
        process = start_service(service)
        if process:
            processes.append((service, process))
            time.sleep(2)  # ç­‰å¾…æœåŠ¡å¯åŠ¨
    
    # ç­‰å¾…æœåŠ¡å°±ç»ª
    print("Waiting for services to be ready...")
    time.sleep(10)
    
    # æ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€
    for service, process in processes:
        if service["port"]:
            if check_service_health(service["port"]):
                print(f"âœ… {service['name']} is healthy")
            else:
                print(f"âŒ {service['name']} is not responding")
        else:
            print(f"â„¹ï¸  {service['name']} started (no health check)")
    
    print("\nğŸš€ All services started!")
    print("\nService URLs:")
    print("- Config Manager: http://localhost:8000")
    print("- Website Scanner: http://localhost:8001")
    print("- Alert Handler: http://localhost:8002")
    print("- Web Admin: http://localhost:3000 (start separately)")
    
    try:
        # ä¿æŒè„šæœ¬è¿è¡Œ
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\nShutting down services...")
        for service, process in processes:
            process.terminate()
        print("All services stopped.")

if __name__ == "__main__":
    main()
```

### 4. Docker Compose é›†æˆéƒ¨ç½²

åˆ›å»ºæ ¹ç›®å½•ä¸‹çš„ `docker-compose.yml`ï¼š

```yaml
version: '3.8'

services:
  # æ•°æ®åº“æœåŠ¡
  mongodb:
    image: mongo:5.0
    container_name: mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGODB_USERNAME}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGODB_PASSWORD}
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    container_name: redis
    restart: unless-stopped
    command: redis-server --requirepass ${REDIS_PASSWORD}
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - app-network

  rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq
    restart: unless-stopped
    environment:
      RABBITMQ_DEFAULT_USER: admin
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}
    ports:
      - "5672:5672"
      - "15672:15672"
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    networks:
      - app-network

  # å¾®æœåŠ¡
  config-manager:
    build: ./config-manager
    container_name: config-manager
    restart: unless-stopped
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=sqlite:///./data/config.db
      - SECRET_KEY=${SECRET_KEY}
    volumes:
      - ./config-manager/data:/app/data
    networks:
      - app-network
    depends_on:
      - mongodb
      - redis

  website-scanner:
    build: ./website-scanner
    container_name: website-scanner
    restart: unless-stopped
    ports:
      - "8001:8001"
    environment:
      - MONGODB_URL=mongodb://${MONGODB_USERNAME}:${MONGODB_PASSWORD}@mongodb:27017
      - CONTENT_API_KEY=${CONTENT_API_KEY}
    networks:
      - app-network
    depends_on:
      - mongodb
      - config-manager

  alert-handler:
    build: ./alert-handler
    container_name: alert-handler
    restart: unless-stopped
    ports:
      - "8002:8002"
    environment:
      - DATABASE_URL=postgresql://${POSTGRES_USERNAME}:${POSTGRES_PASSWORD}@postgres:5432/alerts
      - CELERY_BROKER_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
      - EMAIL_API_KEY=${EMAIL_API_KEY}
      - SMS_API_KEY=${SMS_API_KEY}
    networks:
      - app-network
    depends_on:
      - redis
      - rabbitmq
      - config-manager

  task-scheduler:
    build: ./task-scheduler
    container_name: task-scheduler
    restart: unless-stopped
    environment:
      - CELERY_BROKER_URL=amqp://admin:${RABBITMQ_PASSWORD}@rabbitmq:5672//
      - CELERY_RESULT_BACKEND=redis://:${REDIS_PASSWORD}@redis:6379/1
    networks:
      - app-network
    depends_on:
      - rabbitmq
      - redis

  web-admin:
    build: ./web-admin
    container_name: web-admin
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - VUE_APP_API_BASE_URL=http://localhost:8000
    networks:
      - app-network
    depends_on:
      - config-manager
      - website-scanner
      - alert-handler

volumes:
  mongodb_data:
  redis_data:
  rabbitmq_data:

networks:
  app-network:
    driver: bridge
```

## å¯¹æ¥æµ‹è¯•æ–¹æ¡ˆ

### 1. å•å…ƒæµ‹è¯•

æ¯ä¸ªæœåŠ¡éƒ½åº”è¯¥æœ‰å®Œæ•´çš„APIæµ‹è¯•ï¼š

**tests/integration/test_service_integration.py**
```python
import pytest
import httpx
import asyncio

class TestServiceIntegration:
    
    @pytest.mark.asyncio
    async def test_config_to_scanner_integration(self):
        """æµ‹è¯•é…ç½®æœåŠ¡åˆ°æ‰«ææœåŠ¡çš„é›†æˆ"""
        # 1. ä»é…ç½®æœåŠ¡è·å–æ‰«æé…ç½®
        async with httpx.AsyncClient() as client:
            config_response = await client.get(
                "http://localhost:8000/api/v1/configs",
                params={"category": "scanner"}
            )
            assert config_response.status_code == 200
            
            # 2. ä½¿ç”¨é…ç½®å¯åŠ¨æ‰«æä»»åŠ¡
            scan_response = await client.post(
                "http://localhost:8001/api/v1/scan/example.com"
            )
            assert scan_response.status_code == 200
    
    @pytest.mark.asyncio
    async def test_scanner_to_alert_integration(self):
        """æµ‹è¯•æ‰«ææœåŠ¡åˆ°å‘Šè­¦æœåŠ¡çš„é›†æˆ"""
        # æ¨¡æ‹Ÿæ‰«æå‘ç°è¿è§„å†…å®¹ï¼Œè‡ªåŠ¨åˆ›å»ºå‘Šè­¦
        async with httpx.AsyncClient() as client:
            # 1. åˆ›å»ºå‘Šè­¦
            alert_data = {
                "source_module": "website-scanner",
                "target_url": "http://example.com",
                "alert_type": "content_violation",
                "severity": "high",
                "title": "æµ‹è¯•å‘Šè­¦",
                "description": "é›†æˆæµ‹è¯•å‘Šè­¦"
            }
            
            alert_response = await client.post(
                "http://localhost:8002/api/v1/alerts",
                json=alert_data
            )
            assert alert_response.status_code == 200
            
            # 2. éªŒè¯å‘Šè­¦å·²åˆ›å»º
            alerts_response = await client.get(
                "http://localhost:8002/api/v1/alerts"
            )
            assert alerts_response.status_code == 200
            alerts = alerts_response.json()
            assert len(alerts["alerts"]) > 0
```

### 2. ç«¯åˆ°ç«¯æµ‹è¯•

**tests/e2e/test_full_workflow.py**
```python
import pytest
import httpx
import asyncio
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

class TestFullWorkflow:
    
    @pytest.mark.asyncio
    async def test_complete_scan_workflow(self):
        """æµ‹è¯•å®Œæ•´çš„æ‰«æå·¥ä½œæµç¨‹"""
        # 1. é€šè¿‡å‰ç«¯åˆ›å»ºæ‰«æä»»åŠ¡
        driver = webdriver.Chrome()
        try:
            driver.get("http://localhost:3000")
            
            # å¯¼èˆªåˆ°æ‰«æç®¡ç†é¡µé¢
            scan_menu = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.LINK_TEXT, "æ‰«æç®¡ç†"))
            )
            scan_menu.click()
            
            # è¾“å…¥åŸŸåå¹¶å¯åŠ¨æ‰«æ
            domain_input = driver.find_element(By.NAME, "domain")
            domain_input.send_keys("example.com")
            
            start_button = driver.find_element(By.BUTTON, "å¼€å§‹æ‰«æ")
            start_button.click()
            
            # 2. éªŒè¯åç«¯APIè°ƒç”¨
            async with httpx.AsyncClient() as client:
                # æ£€æŸ¥æ‰«æä»»åŠ¡æ˜¯å¦åˆ›å»º
                response = await client.get(
                    "http://localhost:8001/api/v1/results",
                    params={"domain": "example.com"}
                )
                assert response.status_code == 200
                
        finally:
            driver.quit()
```

## éƒ¨ç½²å’Œè¿ç»´

### 1. ç¯å¢ƒé…ç½®

å¤åˆ¶å¹¶é…ç½®ç¯å¢ƒå˜é‡ï¼š
```bash
cp env.example .env
# ç¼–è¾‘ .env æ–‡ä»¶ï¼Œå¡«å…¥å®é™…é…ç½®
```

### 2. å¯åŠ¨æœåŠ¡

**å¼€å‘ç¯å¢ƒï¼š**
```bash
# å¯åŠ¨åç«¯æœåŠ¡
python scripts/start_all_services.py

# å¯åŠ¨å‰ç«¯æœåŠ¡
cd web-admin
npm install
npm run dev
```

**ç”Ÿäº§ç¯å¢ƒï¼š**
```bash
# ä½¿ç”¨Docker Compose
docker-compose up -d
```

### 3. å¥åº·æ£€æŸ¥

åˆ›å»ºå¥åº·æ£€æŸ¥è„šæœ¬ `scripts/health_check.py`ï¼š

```python
import httpx
import asyncio

SERVICES = [
    {"name": "Config Manager", "url": "http://localhost:8000/health"},
    {"name": "Website Scanner", "url": "http://localhost:8001/health"},
    {"name": "Alert Handler", "url": "http://localhost:8002/health"},
]

async def check_service(service):
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(service["url"], timeout=5)
            if response.status_code == 200:
                print(f"âœ… {service['name']}: OK")
                return True
            else:
                print(f"âŒ {service['name']}: HTTP {response.status_code}")
                return False
    except Exception as e:
        print(f"âŒ {service['name']}: {str(e)}")
        return False

async def main():
    print("Checking service health...")
    results = await asyncio.gather(*[check_service(s) for s in SERVICES])
    
    healthy_count = sum(results)
    total_count = len(SERVICES)
    
    print(f"\nHealth check complete: {healthy_count}/{total_count} services healthy")
    
    if healthy_count == total_count:
        print("ğŸ‰ All services are healthy!")
        return 0
    else:
        print("âš ï¸  Some services are not healthy")
        return 1

if __name__ == "__main__":
    exit(asyncio.run(main()))
```

## æ€»ç»“

æœ¬å¯¹æ¥æ–¹æ¡ˆæä¾›äº†ï¼š

1. **å®Œæ•´çš„APIå¯¹æ¥é…ç½®** - å‰ç«¯åˆ°å„ä¸ªå¾®æœåŠ¡çš„APIè°ƒç”¨
2. **æœåŠ¡é—´é€šä¿¡æœºåˆ¶** - å¾®æœåŠ¡ä¹‹é—´çš„æ•°æ®äº¤æ¢å’Œäº‹ä»¶é€šçŸ¥
3. **ç»Ÿä¸€é…ç½®ç®¡ç†** - æ‰€æœ‰æœåŠ¡ä»é…ç½®ä¸­å¿ƒè·å–é…ç½®
4. **å®¹å™¨åŒ–éƒ¨ç½²æ–¹æ¡ˆ** - Docker Compose ä¸€é”®éƒ¨ç½²
5. **æµ‹è¯•å’Œç›‘æ§** - é›†æˆæµ‹è¯•å’Œå¥åº·æ£€æŸ¥æœºåˆ¶

é€šè¿‡è¿™ä¸ªæ–¹æ¡ˆï¼Œå¯ä»¥å®ç°å„ä¸ªå¾®æœåŠ¡çš„å®Œæ•´å¯¹æ¥ï¼Œç¡®ä¿ç³»ç»Ÿçš„ç¨³å®šè¿è¡Œå’Œå¯ç»´æŠ¤æ€§ã€‚