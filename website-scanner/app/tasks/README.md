# 异步任务模块

**功能职责：**

本模块定义了所有可以被Celery Worker异步执行的任务。这些任务通常是耗时的操作，如完整的网站扫描流程，通过将其放入后台执行，可以避免阻塞主应用程序（如FastAPI服务）。

**注意**: 任务的**定义**在此模块，但任务的**调度和执行**由`task-scheduler`模块负责。

## 文件说明

- `__init__.py`: Python包标识文件。
- `scan_tasks.py`: 定义与网站扫描相关的Celery任务。
  - **`@celery_app.task`**: 使用Celery提供的装饰器来定义一个任务。
  - **`run_website_scan(website_id: int, scan_config: dict)`**: 这是一个核心的异步任务函数。它接收一个网站ID和扫描配置作为参数。
    - **任务逻辑**: 
      1. 从数据库中查找`website_id`对应的网站信息。
      2. 实例化`ScanManager`服务。
      3. 调用`scan_manager.execute_scan()`方法，并传入网站信息和配置。
      4. `execute_scan`方法会协调`Crawler`, `ContentChecker`等服务完成整个扫描流程。
      5. 任务执行过程中，应更新`ScanTask`在数据库中的状态（如从`PENDING`到`RUNNING`，再到`SUCCESS`或`FAILURE`）。
      6. 处理异常，并在任务失败时记录详细的错误信息。

## 开发规范

- **任务幂等性**: 尽量设计幂等的任务。即，一个任务即使被重复执行多次，其结果也应该和执行一次相同。这对于保证在系统故障或消息重传时的可靠性至关重要。
  - 例如，在开始扫描前，可以检查是否已存在一个针对该网站且配置相同的、近期完成的扫描任务。
- **任务原子性**: 任务应该是原子操作。如果一个任务包含多个步骤，应考虑如何处理部分失败的情况。可以使用Celery的重试机制或事务来保证数据的一致性。
- **参数序列化**: 传递给任务的参数必须是可序列化的（如JSON）。因此，不要直接传递复杂的对象实例（如数据库模型对象），而应该传递它们的ID（如`website_id`），然后在任务内部根据ID重新从数据库中获取对象。
- **任务粒度**: 保持任务的粒度适中。过于庞大的任务难以管理和调试，而过于细小的任务可能会导致过多的任务调度开销。
- **错误处理与重试**: 在任务代码中添加健壮的`try...except`块来捕获异常。对于可恢复的错误（如临时的网络问题），可以使用`self.retry(exc=e, countdown=60)`来配置自动重试。
- **状态更新**: 任务执行的关键阶段应及时更新数据库中相关记录的状态，以便前端可以展示任务的实时进度。